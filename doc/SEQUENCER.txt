

Design of SEQUENCER, a total order protocol using a sequencer
=============================================================

Author: Bela Ban
Date: Dec 29 2005
Version: $Id: SEQUENCER.txt,v 1.8 2006/01/05 17:17:15 belaban Exp $


Motivation
----------
The TOTAL protocol works by asking the coordinator for a sequence number for every group message, but each member
sends the message itself. This means a round trip to the coordinator, then a multicast. In the design below, we want
the coordinator to directly multicast the message on behalf of the member, now we have 1 unicast to the coordinator and
1 multicast. The downside is that all message are now routed via the coordinator, which makes the latter the
bottleneck. However, since it is only the coordinator who sends multicasts, we have no contention.

Overview
--------
When a member multicasts a group message, it sends it to the coordinator. The coord then wraps the message into
its own message and multicasts it to the group. The SEQUENCER protocol (somewhere above NAKACK) unwraps the message
so that the original sender is seen.

Example: group is {A,B,C}. B wants to multicast a message M to the group. It does so by sending M to A. A then
adds a header which records the original sender (B) and replaces M's sender address with its own (A).
When a member receives M, everybody thinks the message is from A, and NAKACK will possibly retransmit from A
in case M is lost. However, SEQUENCER removes the header and replaces M's sender address with B. It has to
do so on a (shallow) *copy* of M, otherwise we would change the original message and therefore retransmission
requests would go to B, rather than A !

Design
------

Variables:
- forward-table: Map<seqno, Message>, list of messages to be forwarded (sorted by seqno)
                 that have not yet been received (as bcasts)
- received-table: Map<Address, Long> which keeps the highest seqno seen per member. This table has N
                  entries, where N is the number of members in the group

On send(M):
- Pass down unicasts and return (handle only multicasts)
- Add a FORWARD header to M with the local_addr and a monotonically increasing seqno (use a ViewId ?)
- If not coordinator:
  - Add message to the forward-table (when a broadcast is received,
                                      remove the corresponding message from the forward-table)
  - Send M to coordinator
- Else
  - Multicast(M)


On stop():
- Stop handling new down messages
- Wait for all replies until forward-table is empty, or a timeout (?)


On reception of M from S:
- If header is not present:
  - Pass up
- Else (header is present)
  - If header is FORWARD:
    - If not coord: error and return
    - Else
      - Multicast(M,S)
  - If header is DATA:
    - Take sender S from header and call Deliver(M,S)


Multicast(M,S):
- Reuse M (no problem since UNICAST's retransmission buffer will have remove M when passed to SEQUENCER)
- Replace FORWARD type in header with DATA type(stores S)
- Multicast M

Deliver(M,S):
- If M was sent by us (local_addr == S):
  - remove corresponding message from forward-table
- If M was already delivered (M's seqno is <= the one in received-table):
  - Discard M
- Else:
  - Update the received-table with M's seqno with key=S
    (needs to be 1 higher then prev seqno)
  - Shallow-copy M into M-tmp
  - Set M-tmp's sender address to S
  - Pass up M-tmp


On view change:
- If the coord leaves/crashes:
  - For each message M in forward-table (*in increasing order of seqnos* !):
    - Change M.dest to the new coord
    - Send M to the new coord

Comments
--------
When forwarding we don't care about whether the message was forwarded before, e.g. by the previous
coordinator. We simply forward, but discard duplicate messages when receiving the bcast. This is not
overly efficient when failing over between coordinators, but makes the implementation simpler.









