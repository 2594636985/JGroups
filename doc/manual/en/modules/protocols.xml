<?xml version="1.0" encoding="UTF-8"?>
<chapter id="protlist">
    <title>List of Protocols</title>

    <para>
        This section is work in progress; we strive to update the documentation as we make changes to the code.
    </para>
    <para>
        The most important properties are described on the
        <ulink url="http://www.jboss.org/wiki/Wiki.jsp?page=JGroups">wiki</ulink>. The idea is that users take one
        of the predefined configurations (shipped with JGroups) and make only minor changes to it.
    </para>

    <para>For each protocol define:</para>

    <itemizedlist>
        <listitem>
            <para>Properties provided</para>
        </listitem>

        <listitem>
            <para>Required services</para>
        </listitem>

        <listitem>
            <para>Provided services</para>
        </listitem>

        <listitem>
            <para>Behavior</para>
        </listitem>
    </itemizedlist>

    <section>
        <title>Transport</title>

        <section>
            <title>UDP</title>
            
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>The interface (NIC) which should be used by this transport </entry>
</row>
<row>
<entry>bind_port</entry>
<entry>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</entry>
</row>
<row>
<entry>diagnostics_addr</entry>
<entry>Address for diagnostic probing. Default is 224.0.75.75</entry>
</row>
<row>
<entry>diagnostics_port</entry>
<entry>Port for diagnostic probing. Default is 7500</entry>
</row>
<row>
<entry>discard_incompatible_packets</entry>
<entry>Discard packets with a different version if true. Default is false</entry>
</row>
<row>
<entry>enable_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones. Default is true</entry>
</row>
<row>
<entry>enable_diagnostics</entry>
<entry>Switch to enable diagnostic probing. Default is true</entry>
</row>
<row>
<entry>enable_unicast_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones for unicast messages. Default is false</entry>
</row>
<row>
<entry>ip_mcast</entry>
<entry>Multicast toggle. If false multiple unicast datagrams are sent instead of one multicast. Default is true</entry>
</row>
<row>
<entry>ip_ttl</entry>
<entry>The time-to-live (TTL) for multicast datagram packets. Default is 8</entry>
</row>
<row>
<entry>loopback</entry>
<entry>Messages to self are looped back immediately if true. Default is false</entry>
</row>
<row>
<entry>mcast_addr_name</entry>
<entry>The multicast address used for sending and receiving packets. Default is 228.8.8.8</entry>
</row>
<row>
<entry>mcast_port</entry>
<entry>The multicast port used for sending and receiving packets. Default is 7600</entry>
</row>
<row>
<entry>mcast_recv_buf_size</entry>
<entry>Receive buffer size of the multicast datagram socket. Default is 500'000 bytes</entry>
</row>
<row>
<entry>mcast_send_buf_size</entry>
<entry>Send buffer size of the multicast datagram socket. Default is 100'000 bytes</entry>
</row>
<row>
<entry>num_timer_threads</entry>
<entry>Number of threads to be used by the timer thread pool. Default is 4</entry>
</row>
<row>
<entry>oob_thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for OOB messages. Default true</entry>
</row>
<row>
<entry>oob_thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from OOB pool. Default is 30000</entry>
</row>
<row>
<entry>oob_thread_pool_max_threads</entry>
<entry>Maximum thread pool size for OOB messages. Default is 10</entry>
</row>
<row>
<entry>oob_thread_pool_min_threads</entry>
<entry>Minimum thread pool size for OOB messages. Default is 2</entry>
</row>
<row>
<entry>oob_thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming OOB messages. Default is true</entry>
</row>
<row>
<entry>oob_thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>oob_thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Run</entry>
</row>
<row>
<entry>persistent_ports</entry>
<entry>Switch to enable tracking of currently used ports on this machine. Default is false</entry>
</row>
<row>
<entry>persistent_ports_file</entry>
<entry>Path to a file to store currently used ports on this machine.</entry>
</row>
<row>
<entry>pm_expiry_time</entry>
<entry>Timeout to expire ports used with PortManager. Default is 30000 msec</entry>
</row>
<row>
<entry>port_range</entry>
<entry/>
</row>
<row>
<entry>prevent_port_reuse</entry>
<entry>TODO</entry>
</row>
<row>
<entry>receive_interfaces</entry>
<entry>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</entry>
</row>
<row>
<entry>receive_on_all_interfaces</entry>
<entry> If true, the transport should use all available interfaces to receive multicast messages. Default is false</entry>
</row>
<row>
<entry>singleton_name</entry>
<entry>If assigned enable this transport to be a singleton (shared) transport</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>thread_naming_pattern</entry>
<entry>Thread naming pattern for threads in this channel. Default is cl</entry>
</row>
<row>
<entry>thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for regular messages. Default true</entry>
</row>
<row>
<entry>thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from regular pool. Default is 30000</entry>
</row>
<row>
<entry>thread_pool_max_threads</entry>
<entry>Maximum thread pool size for regular messages. Default is 10</entry>
</row>
<row>
<entry>thread_pool_min_threads</entry>
<entry>Minimum thread pool size for regular messages. Default is 2</entry>
</row>
<row>
<entry>thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming regular messages. Default is true</entry>
</row>
<row>
<entry>thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run Default is Run</entry>
</row>
<row>
<entry>tos</entry>
<entry>Traffic class for sending unicast and multicast datagrams. Default is 8</entry>
</row>
<row>
<entry>ucast_recv_buf_size</entry>
<entry>Receive buffer size of the unicast datagram socket. Default is 64'000 bytes</entry>
</row>
<row>
<entry>ucast_send_buf_size</entry>
<entry>Send buffer size of the unicast datagram socket. Default is 100'000 bytes</entry>
</row>
<row>
<entry>use_local_host</entry>
<entry>Ignores all bind address parameters and  let's the OS return the local host address. Default is false</entry>
</row>
</tbody>
</tgroup>
</table>
			          

            <para></para>
        </section>

        <section>
            <title>TCP</title>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>The interface (NIC) which should be used by this transport </entry>
</row>
<row>
<entry>bind_port</entry>
<entry>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</entry>
</row>
<row>
<entry>conn_expire_time</entry>
<entry>Max time connection can be idle before being reaped</entry>
</row>
<row>
<entry>diagnostics_addr</entry>
<entry>Address for diagnostic probing. Default is 224.0.75.75</entry>
</row>
<row>
<entry>diagnostics_port</entry>
<entry>Port for diagnostic probing. Default is 7500</entry>
</row>
<row>
<entry>discard_incompatible_packets</entry>
<entry>Discard packets with a different version if true. Default is false</entry>
</row>
<row>
<entry>enable_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones. Default is true</entry>
</row>
<row>
<entry>enable_diagnostics</entry>
<entry>Switch to enable diagnostic probing. Default is true</entry>
</row>
<row>
<entry>enable_unicast_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones for unicast messages. Default is false</entry>
</row>
<row>
<entry>external_addr</entry>
<entry>Use "external_addr" if you have hosts on different networks, behind firewalls. On each firewall, set up a port forwarding rule (sometimes called "virtual server") to the local IP (e.g. 192.168.1.100) of the host then on each host, set "external_addr" TCP transport parameter to the external (public IP) address of the firewall. </entry>
</row>
<row>
<entry>linger</entry>
<entry>SO_LINGER in msec. Default of -1 disables it</entry>
</row>
<row>
<entry>loopback</entry>
<entry>Messages to self are looped back immediately if true. Default is false</entry>
</row>
<row>
<entry>num_timer_threads</entry>
<entry>Number of threads to be used by the timer thread pool. Default is 4</entry>
</row>
<row>
<entry>oob_thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for OOB messages. Default true</entry>
</row>
<row>
<entry>oob_thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from OOB pool. Default is 30000</entry>
</row>
<row>
<entry>oob_thread_pool_max_threads</entry>
<entry>Maximum thread pool size for OOB messages. Default is 10</entry>
</row>
<row>
<entry>oob_thread_pool_min_threads</entry>
<entry>Minimum thread pool size for OOB messages. Default is 2</entry>
</row>
<row>
<entry>oob_thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming OOB messages. Default is true</entry>
</row>
<row>
<entry>oob_thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>oob_thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Run</entry>
</row>
<row>
<entry>peer_addr_read_timeout</entry>
<entry>Max time to block on reading of peer address. Default is 1000 msec</entry>
</row>
<row>
<entry>persistent_ports</entry>
<entry>Switch to enable tracking of currently used ports on this machine. Default is false</entry>
</row>
<row>
<entry>persistent_ports_file</entry>
<entry>Path to a file to store currently used ports on this machine.</entry>
</row>
<row>
<entry>pm_expiry_time</entry>
<entry>Timeout to expire ports used with PortManager. Default is 30000 msec</entry>
</row>
<row>
<entry>port_range</entry>
<entry/>
</row>
<row>
<entry>prevent_port_reuse</entry>
<entry>TODO</entry>
</row>
<row>
<entry>reaper_interval</entry>
<entry>Reaper interval in msec. Default is 0 (no reaping)</entry>
</row>
<row>
<entry>receive_interfaces</entry>
<entry>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</entry>
</row>
<row>
<entry>receive_on_all_interfaces</entry>
<entry> If true, the transport should use all available interfaces to receive multicast messages. Default is false</entry>
</row>
<row>
<entry>recv_buf_size</entry>
<entry>Receiver buffer size in bytes. Default is 150000 bytes</entry>
</row>
<row>
<entry>send_buf_size</entry>
<entry>Send buffer size in bytes. Default is 150000 bytes</entry>
</row>
<row>
<entry>send_queue_size</entry>
<entry>Max number of messages in a send queue. Default is 10000 messages</entry>
</row>
<row>
<entry>singleton_name</entry>
<entry>If assigned enable this transport to be a singleton (shared) transport</entry>
</row>
<row>
<entry>skip_suspected_members</entry>
<entry>Should unicast messages to suspected members be dropped. Default is false</entry>
</row>
<row>
<entry>sock_conn_timeout</entry>
<entry>Max time allowed for a socket creation in ConnectionTable. Default is 2000 msec</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>suspect_on_send_failure</entry>
<entry>If cannot send a message to P (on an exception), should SUSPECT message be raised. Default is false</entry>
</row>
<row>
<entry>tcp_nodelay</entry>
<entry>Should TCP no delay flag be turned on. Default is false</entry>
</row>
<row>
<entry>thread_naming_pattern</entry>
<entry>Thread naming pattern for threads in this channel. Default is cl</entry>
</row>
<row>
<entry>thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for regular messages. Default true</entry>
</row>
<row>
<entry>thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from regular pool. Default is 30000</entry>
</row>
<row>
<entry>thread_pool_max_threads</entry>
<entry>Maximum thread pool size for regular messages. Default is 10</entry>
</row>
<row>
<entry>thread_pool_min_threads</entry>
<entry>Minimum thread pool size for regular messages. Default is 2</entry>
</row>
<row>
<entry>thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming regular messages. Default is true</entry>
</row>
<row>
<entry>thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run Default is Run</entry>
</row>
<row>
<entry>use_local_host</entry>
<entry>Ignores all bind address parameters and  let's the OS return the local host address. Default is false</entry>
</row>
<row>
<entry>use_send_queues</entry>
<entry>Should separate send queues be used for each connection. Default is true</entry>
</row>
</tbody>
</tgroup>
</table>

			
            <para></para>
        </section>        

        <section>
            <title>TUNNEL</title>
            
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>The interface (NIC) which should be used by this transport </entry>
</row>
<row>
<entry>bind_port</entry>
<entry>The port to which the transport binds. Default of 0 binds to any (ephemeral) port</entry>
</row>
<row>
<entry>diagnostics_addr</entry>
<entry>Address for diagnostic probing. Default is 224.0.75.75</entry>
</row>
<row>
<entry>diagnostics_port</entry>
<entry>Port for diagnostic probing. Default is 7500</entry>
</row>
<row>
<entry>discard_incompatible_packets</entry>
<entry>Discard packets with a different version if true. Default is false</entry>
</row>
<row>
<entry>enable_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones. Default is true</entry>
</row>
<row>
<entry>enable_diagnostics</entry>
<entry>Switch to enable diagnostic probing. Default is true</entry>
</row>
<row>
<entry>enable_unicast_bundling</entry>
<entry>Enable bundling of smaller messages into bigger ones for unicast messages. Default is false</entry>
</row>
<row>
<entry>loopback</entry>
<entry>Messages to self are looped back immediately if true. Default is false</entry>
</row>
<row>
<entry>num_timer_threads</entry>
<entry>Number of threads to be used by the timer thread pool. Default is 4</entry>
</row>
<row>
<entry>oob_thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for OOB messages. Default true</entry>
</row>
<row>
<entry>oob_thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from OOB pool. Default is 30000</entry>
</row>
<row>
<entry>oob_thread_pool_max_threads</entry>
<entry>Maximum thread pool size for OOB messages. Default is 10</entry>
</row>
<row>
<entry>oob_thread_pool_min_threads</entry>
<entry>Minimum thread pool size for OOB messages. Default is 2</entry>
</row>
<row>
<entry>oob_thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming OOB messages. Default is true</entry>
</row>
<row>
<entry>oob_thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>oob_thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run. Default is Run</entry>
</row>
<row>
<entry>persistent_ports</entry>
<entry>Switch to enable tracking of currently used ports on this machine. Default is false</entry>
</row>
<row>
<entry>persistent_ports_file</entry>
<entry>Path to a file to store currently used ports on this machine.</entry>
</row>
<row>
<entry>pm_expiry_time</entry>
<entry>Timeout to expire ports used with PortManager. Default is 30000 msec</entry>
</row>
<row>
<entry>port_range</entry>
<entry/>
</row>
<row>
<entry>prevent_port_reuse</entry>
<entry>TODO</entry>
</row>
<row>
<entry>receive_interfaces</entry>
<entry>Comma delimited list of interfaces (IP addresses or interface names) to receive multicasts on</entry>
</row>
<row>
<entry>receive_on_all_interfaces</entry>
<entry> If true, the transport should use all available interfaces to receive multicast messages. Default is false</entry>
</row>
<row>
<entry>reconnect_interval</entry>
<entry>Interval in msec to attempt connecting back to router in case of torn connection. Default is 5000 msec</entry>
</row>
<row>
<entry>router_host</entry>
<entry>Router host address</entry>
</row>
<row>
<entry>router_port</entry>
<entry>Router port</entry>
</row>
<row>
<entry>singleton_name</entry>
<entry>If assigned enable this transport to be a singleton (shared) transport</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>thread_naming_pattern</entry>
<entry>Thread naming pattern for threads in this channel. Default is cl</entry>
</row>
<row>
<entry>thread_pool_enabled</entry>
<entry>Switch for enabling thread pool for regular messages. Default true</entry>
</row>
<row>
<entry>thread_pool_keep_alive_time</entry>
<entry>Timeout in milliseconds to remove idle thread from regular pool. Default is 30000</entry>
</row>
<row>
<entry>thread_pool_max_threads</entry>
<entry>Maximum thread pool size for regular messages. Default is 10</entry>
</row>
<row>
<entry>thread_pool_min_threads</entry>
<entry>Minimum thread pool size for regular messages. Default is 2</entry>
</row>
<row>
<entry>thread_pool_queue_enabled</entry>
<entry>Use queue to enqueue incoming regular messages. Default is true</entry>
</row>
<row>
<entry>thread_pool_queue_max_size</entry>
<entry>Maximum queue size for incoming OOB messages. Default is 500</entry>
</row>
<row>
<entry>thread_pool_rejection_policy</entry>
<entry>Thread rejection policy. Possible values are Abort, Discard, DiscardOldest and Run Default is Run</entry>
</row>
<row>
<entry>use_local_host</entry>
<entry>Ignores all bind address parameters and  let's the OS return the local host address. Default is false</entry>
</row>
</tbody>
</tgroup>
</table>

            

            <para></para>
        </section>       
    </section>

    <section>
        <title>Initial membership discovery</title>

        <section>
            <title>PING</title>
            
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>break_on_coord_rsp</entry>
<entry>Return from the discovery phase as soon as we have 1 coordinator response</entry>
</row>
<row>
<entry>discovery_timeout</entry>
<entry>Time (in ms) to wait for our own discovery message to be received. 0 means don't wait. If the discovery message is not received within discovery_timeout ms, a warning will be logged</entry>
</row>
<row>
<entry>gossip_host</entry>
<entry>Gossip host</entry>
</row>
<row>
<entry>gossip_port</entry>
<entry>Gossip port</entry>
</row>
<row>
<entry>gossip_refresh</entry>
<entry>Time in msecs after which the entry in GossipRouter will be refreshed. Default is 20000 msec</entry>
</row>
<row>
<entry>num_initial_members</entry>
<entry>Minimum number of initial members to get a response from. Default is 2</entry>
</row>
<row>
<entry>num_initial_srv_members</entry>
<entry>Minimum number of server responses (PingRsp.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</entry>
</row>
<row>
<entry>num_ping_requests</entry>
<entry>Number of discovery requests to be sent distributed over timeout. Default is 2</entry>
</row>
<row>
<entry>port_range</entry>
<entry>Number of ports to be probed for initial membership. Default is 1</entry>
</row>
<row>
<entry>socket_conn_timeout</entry>
<entry>If socket is used for discovery, time in msecs to wait until socket is connected. Default is 1000 msec</entry>
</row>
<row>
<entry>socket_read_timeout</entry>
<entry>Max to block on the socket on a read (in ms). 0 means block forever</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout to wait for the initial members. Default is 3000 msec</entry>
</row>
</tbody>
</tgroup>
</table>

            <para></para>
        </section>

        <section>
            <title>TCPPING</title>
            
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>break_on_coord_rsp</entry>
<entry>Return from the discovery phase as soon as we have 1 coordinator response</entry>
</row>
<row>
<entry>hosts</entry>
<entry>Comma delimeted list of hosts to be contacted for initial membership</entry>
</row>
<row>
<entry>num_initial_members</entry>
<entry>Minimum number of initial members to get a response from. Default is 2</entry>
</row>
<row>
<entry>num_initial_srv_members</entry>
<entry>Minimum number of server responses (PingRsp.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</entry>
</row>
<row>
<entry>num_ping_requests</entry>
<entry>Number of discovery requests to be sent distributed over timeout. Default is 2</entry>
</row>
<row>
<entry>port_range</entry>
<entry>Number of ports to be probed for initial membership. Default is 1</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout to wait for the initial members. Default is 3000 msec</entry>
</row>
</tbody>
</tgroup>
</table>


            <para></para>
        </section>

        <section>
            <title>TCPGOSSIP</title>
            
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>break_on_coord_rsp</entry>
<entry>Return from the discovery phase as soon as we have 1 coordinator response</entry>
</row>
<row>
<entry>gossip_refresh_rate</entry>
<entry>Rate of continious refresh registering of underlying gossip client with gossip server. Default is 20000 msec</entry>
</row>
<row>
<entry>num_initial_members</entry>
<entry>Minimum number of initial members to get a response from. Default is 2</entry>
</row>
<row>
<entry>num_initial_srv_members</entry>
<entry>Minimum number of server responses (PingRsp.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</entry>
</row>
<row>
<entry>num_ping_requests</entry>
<entry>Number of discovery requests to be sent distributed over timeout. Default is 2</entry>
</row>
<row>
<entry>sock_conn_timeout</entry>
<entry>Max time for socket creation. Default is 1000 msec</entry>
</row>
<row>
<entry>sock_read_timeout</entry>
<entry>Max time in milliseconds to block on a read. 0 blocks forever</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout to wait for the initial members. Default is 3000 msec</entry>
</row>
</tbody>
</tgroup>
</table>


            <para></para>
        </section>

        <section>
            <title>MPING</title>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>Bind address for multicast socket</entry>
</row>
<row>
<entry>break_on_coord_rsp</entry>
<entry>Return from the discovery phase as soon as we have 1 coordinator response</entry>
</row>
<row>
<entry>discovery_timeout</entry>
<entry>Time (in ms) to wait for our own discovery message to be received. 0 means don't wait. If the discovery message is not received within discovery_timeout ms, a warning will be logged</entry>
</row>
<row>
<entry>gossip_host</entry>
<entry>Gossip host</entry>
</row>
<row>
<entry>gossip_port</entry>
<entry>Gossip port</entry>
</row>
<row>
<entry>gossip_refresh</entry>
<entry>Time in msecs after which the entry in GossipRouter will be refreshed. Default is 20000 msec</entry>
</row>
<row>
<entry>ip_ttl</entry>
<entry>Time to live for discovery packets. Default is 8</entry>
</row>
<row>
<entry>mcast_port</entry>
<entry>Multicast port for discovery packets. Default is 7555</entry>
</row>
<row>
<entry>num_initial_members</entry>
<entry>Minimum number of initial members to get a response from. Default is 2</entry>
</row>
<row>
<entry>num_initial_srv_members</entry>
<entry>Minimum number of server responses (PingRsp.isServer()=true). If this value is greater than 0, we'll ignore num_initial_members</entry>
</row>
<row>
<entry>num_ping_requests</entry>
<entry>Number of discovery requests to be sent distributed over timeout. Default is 2</entry>
</row>
<row>
<entry>port_range</entry>
<entry>Number of ports to be probed for initial membership. Default is 1</entry>
</row>
<row>
<entry>receive_interfaces</entry>
<entry>List of interfaces to receive multicasts on</entry>
</row>
<row>
<entry>receive_on_all_interfaces</entry>
<entry>If true, the transport should use all available interfaces to receive multicast messages. Default is false</entry>
</row>
<row>
<entry>send_interfaces</entry>
<entry>List of interfaces to send multicasts on</entry>
</row>
<row>
<entry>send_on_all_interfaces</entry>
<entry>Whether send messages are sent on all interfaces. Default is false</entry>
</row>
<row>
<entry>socket_conn_timeout</entry>
<entry>If socket is used for discovery, time in msecs to wait until socket is connected. Default is 1000 msec</entry>
</row>
<row>
<entry>socket_read_timeout</entry>
<entry>Max to block on the socket on a read (in ms). 0 means block forever</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout to wait for the initial members. Default is 3000 msec</entry>
</row>
</tbody>
</tgroup>
</table>

            <para></para>
        </section>
    </section>

    <section>
        <title>Merging after a network partition</title>

        <section>
            <title>MERGE2</title>
				<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>max_interval</entry>
<entry>Upper bound in msec to run merge protocol. Default is 20000 msec</entry>
</row>
<row>
<entry>min_interval</entry>
<entry>Lower bound in msec to run merge protocol. Default is 5000 msec</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>


            <para></para>
        </section>
    </section>

    <section>


        <title>Failure Detection</title>

        The task of failure detection is to probe members of a group and see whether they are alive. When a member is
        suspected (= deemed dead), then a SUSPECT message is sent to all nodes of the cluster. It is not the task of the
        failure detection layer to exclude a crashed member (this is done by the group membership protocol, GMS), but
        simply to notify everyone that a node in the cluster is suspected of having crashed.

        <section>
            <title>FD</title>

            <para>Failure detection based on heartbeat messages. If reply is not
                received without timeout ms, max_tries times, a member is declared
                suspected, and will be excluded by GMS
            </para>

            <para>Each member send a message containing a "FD" - HEARTBEAT header to
                its neighbor to the right (identified by the ping_dest address). The
                heartbeats are sent by the inner class Monitor. When the neighbor
                receives the HEARTBEAT, it replies with a message containing a "FD" -
                HEARTBEAT_ACK header. The first member watches for "FD" - HEARTBEAT_ACK
                replies from its neigbor. For each received reply, it resets the
                last_ack timestamp (sets it to current time) and num_tries counter (sets
                it to 0). The same Monitor instance that sends heartbeats whatches the
                difference between current time and last_ack. If this difference grows
                over timeout, the Monitor cycles several more times (until max_tries) is
                reached) and then sends a SUSPECT message for the neighbor's address.
                The SUSPECT message is sent down the stack, is addressed to all members,
                and is as a regular message with a FdHeader.SUSPECT header.
            </para>

            <table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>max_tries</entry>
<entry>Number of times to send heartbeat. Default is 2</entry>
</row>
<row>
<entry>shun</entry>
<entry>Shun switch. Default is true</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout to suspect a node P if neither a heartbeat nor data were received from P. Default is 3000 msec</entry>
</row>
</tbody>
</tgroup>
</table>

        </section>


        <section>
            <title>FD_ALL</title>

            <para>Failure detection based on simple heartbeat protocol. Every member periodically multicasts a
                heartbeat.
                Every member also maintains a table of all members (minus itself). When data or a heartbeat from P are
                received, we reset the timestamp for P to the current time.
                Periodically, we check for expired members, and suspect those.
            </para>
            <para>
                Example: &lt;FD_ALL interval="3000" timeout="10000"/&gt;
            </para>
            <para>
                In the exampe above, we send a heartbeat every 3 seconds and suspect members if we haven't received a
                heartbeat (or traffic) for more than 10 seconds. Note that since we check the timestamps every
                'interval'
                milliseconds, we will suspect a member after roughly 4 * 3s == 12 seconds. If we set the timeout to
                8500,
                then we would suspect a member after 3 * 3 secs == 9 seconds.
            </para>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>interval</entry>
<entry>Interval in which a HEARTBEAT is sent to the cluster. Default is 3000 msec</entry>
</row>
<row>
<entry>msg_counts_as_heartbeat</entry>
<entry>Treat messages received from members as heartbeats. Note that this means we're updating a value in a hashmap every time a message is passing up the stack through FD_ALL, which is costly. Default is false</entry>
</row>
<row>
<entry>shun</entry>
<entry>Shun switch. Default is true</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Timeout after which a node P is suspected if neither a heartbeat nor data were received from P. Default is 5000 msec</entry>
</row>
</tbody>
</tgroup>
</table>


        </section>


        <section>
            <title>FD_SIMPLE</title>

            <para/>
        </section>


        <section>
            <title>FD_PING</title>
            FD_PING uses a script or command that is
            run with 1 argument (the host to be pinged) and needs to return 0
            (success) or 1 (failure). The default command is /sbin/ping (ping.exe on
            Windows), but this is user configurable and can be replaced with any
            user-provided script or executable.
 
 
			 
 
        </section>


        <section>
            <title>FD_ICMP</title>
            Uses InetAddress.isReachable() to
            determine whether a host is up or not. Note that this is only available in
            JDK 5, so reflection is used to determine whether InetAddress provides
            such a method. If not, an exception will be thrown at protocol
            initialization time.
            <para/>
            The problem with InetAddress.isReachable()
            is that it may or may not use ICMP in its implementation ! For example, an
            implementation might try to establish a TCP connection to port 9 (echo
            service), and - if the echo service is not running - the host would be
            suspected, although a real ICMP packet would
            <emphasis>not</emphasis>
            have
            suspected the host ! Please check your JDK/OS combo before running this
            protocol.
            <table>
                <title>Properties</title>

                <tgroup cols="2">
                    <colspec align="left"/>

                    <thead>
                        <row>
                            <entry align="center">Name</entry>

                            <entry align="center">Description</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry>bind_addr</entry>

                            <entry>The network interface to be used for sending ICMP
                                packets, e.g.
                                <code>bind_addr="192.16.8.0.2"</code>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>


        <section>
            <title>FD_SOCK</title>

            <para>Failure detection protocol based on a ring of TCP sockets created
                between group members. Each member in a group connects to its neighbor
                (last member connects to first) thus forming a ring. Member B is
                suspected when its neighbor A detects abnormally closed TCP socket
                (presumably due to a node B crash). However, if a member B is about to
                leave gracefully, it lets its neighbor A know, so that it does not
                become suspected.
            </para>

            <para>If you are using a multi NIC machine note that JGroups versions
                prior to 2.2.8 have FD_SOCK implementation that does not assume this
                possibility. Therefore JVM can possibly select NIC unreachable to its
                neighbor and setup FD_SOCK server socket on it. Neighbor would be unable
                to connect to that server socket thus resulting in immediate suspecting
                of a member. Suspected member is kicked out of the group, tries to
                rejoin, and thus goes into join/leave loop. JGroups version 2.2.8
                introduces srv_sock_bind_addr property so you can specify network
                interface where FD_SOCK TCP server socket should be bound. This network
                interface is most likely the same interface used for other JGroups
                traffic. JGroups versions 2.2.9 and newer consult bind.address system
                property or you can specify network interface directly as FD_SOCK
                bind_addr property.
            </para>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>The NIC on which the ServerSocket should listen on</entry>
</row>
<row>
<entry>get_cache_timeout</entry>
<entry>Timeout for getting socket cache from coordinator. Default is 1000 msec</entry>
</row>
<row>
<entry>keep_alive</entry>
<entry>Whether to use KEEP_ALIVE on the ping socket or not. Default is true</entry>
</row>
<row>
<entry>num_tries</entry>
<entry>Number of attempts coordinator is solicited for socket cache until we give up. Default is 3</entry>
</row>
<row>
<entry>sock_conn_timeout</entry>
<entry>Max time in millis to wait for ping Socket.connect() to return</entry>
</row>
<row>
<entry>start_port</entry>
<entry>Start port for server socket. Default value of 0 picks a random port</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>suspect_msg_interval</entry>
<entry>Interval for broadcasting suspect messages. Default is 5000 msec</entry>
</row>
</tbody>
</tgroup>
</table>

        </section>


        <section>
            <title>VERIFY_SUSPECT</title>
            <table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>Interface for ICMP pings. Used if use_icmp is true</entry>
</row>
<row>
<entry>num_msgs</entry>
<entry>Number of verify heartbeats sent to a suspected member</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Number of millisecs to wait for a response from a suspected member</entry>
</row>
<row>
<entry>use_icmp</entry>
<entry>Use InetAddress.isReachable() to verify suspected member instead of regular messages</entry>
</row>
</tbody>
</tgroup>
</table>


            <para/>
        </section>


    </section>

    <section>
        <title>Reliable message transmission</title>

        <section>
            <title>pbcast.NAKACK</title>

            <para>
                NAKACK provides reliable delivery and FIFO (= First In First Out) properties for messages sent to all
                nodes in a cluster.
                </para>
            <para>
                Reliable delivery means that no message sent by a sender will ever be lost, as all messages are
                numbered with sequence numbers (by sender) and retransmission requests are sent to the sender of
                a message<footnote>
                <para>
                    Note that NAKACK can also be configured to send retransmission requests for M to
                    <emphasis>anyone</emphasis> in the cluster, rather than only to the sender of M.
                </para>
            </footnote> if that sequence number is not received.
            </para>
            <para>
                FIFO order means that all messages from a given sender are received in exactly the order in which
                they were sent.
            </para>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>discard_delivered_msgs</entry>
<entry>Should messages delivered to application be discarded. Default is false</entry>
</row>
<row>
<entry>eager_lock_release</entry>
<entry>See http://jira.jboss.com/jira/browse/JGRP-656. Default is true</entry>
</row>
<row>
<entry>enable_xmit_time_stats</entry>
<entry>If true, retransmissions stats will be captured. Default is false</entry>
</row>
<row>
<entry>exponential_backoff</entry>
<entry>The first value (in milliseconds) to use in the exponential backoff. Enabled if greater than 0. Default is 0</entry>
</row>
<row>
<entry>gc_lag</entry>
<entry>Garbage collection lag. Default is 20 msec</entry>
</row>
<row>
<entry>max_rebroadcast_timeout</entry>
<entry>Timeout to rebroadcast messages. Default is 2000 msec</entry>
</row>
<row>
<entry>max_xmit_buf_size</entry>
<entry>If value is &gt; 0, the retransmit buffer is bounded. If value &lt;= 0 unbounded buffers are used. Default is 0</entry>
</row>
<row>
<entry>print_stability_history_on_failed_xmit</entry>
<entry>Should stability history be printed if we fail in retransmission. Default is false</entry>
</row>
<row>
<entry>retransmit_timeouts</entry>
<entry>Timeout before requesting retransmissions. Default is 600, 1200, 2400, 4800</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>stats_list_size</entry>
<entry>Size of send and receive history. Default is 20 entries</entry>
</row>
<row>
<entry>use_mcast_xmit</entry>
<entry>Retransmit messages using multicast rather than unicast. Default is true</entry>
</row>
<row>
<entry>use_mcast_xmit_req</entry>
<entry>Use a multicast to request retransmission of missing messages. Default is false</entry>
</row>
<row>
<entry>use_stats_for_retransmission</entry>
<entry>Use statistics gathered from actual retransmission times to compute new retransmission times. Default is false</entry>
</row>
<row>
<entry>xmit_from_random_member</entry>
<entry>Ask a random member for retransmission of a missing message. Default is false</entry>
</row>
<row>
<entry>xmit_history_max_size</entry>
<entry>Size of retransmission history. Default is 50 entries</entry>
</row>
</tbody>
</tgroup>
</table>


        </section>

         <section>
            <title>UNICAST</title>

            <para>
                UNICAST provides reliable delivery and FIFO (= First In First Out) properties for point-to-point
                messages between one sender and one receiver.
                </para>
            <para>
                Reliable delivery means that no message sent by a sender will ever be lost, as all messages are
                numbered with sequence numbers (by sender) and retransmission requests are sent to the sender of
                a message<footnote>
            </footnote> if that sequence number is not received.
            </para>
            <para>
                FIFO order means that all messages from a given sender are received in exactly the order in which
                they were sent.
            </para>
             <para>
                 On top of a reliable transport, such as TCP, UNICAST is not really needed. However, concurrent
                 delivery of messages from the same sender is prevented by UNICAST by acquiring a lock on the sender's
                 retransmission table, so unless concurrent delivery is desired, UNICAST should not be removed from
                 the stack even if TCP is used.
             </para>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>eager_lock_release</entry>
<entry>See http://jira.jboss.com/jira/browse/JGRP-656. Default is true</entry>
</row>
<row>
<entry>immediate_ack</entry>
<entry>Acks a message before it is processed by the application to limit unnecessary retransmits. Default is false</entry>
</row>
<row>
<entry>loopback</entry>
<entry>Whether to loop back messages sent to self. Default is false</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>use_gms</entry>
<entry>If GMS should be consulted for the membership on retransmit. Default is true</entry>
</row>
</tbody>
</tgroup>
</table>


         </section>       
    </section>

    <section>
        <title>Fragmentation</title>

        <section>
            <title>FRAG and FRAG2</title>

            <para></para>
            
            <table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>frag_size</entry>
<entry>The max number of bytes in a message. Larger messages will be fragmented. Default is 8192 bytes</entry>
</row>
<row>
<entry>max_retained_buffer</entry>
<entry>The max size in bytes for the byte array output buffer</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>

        </section>
    </section>

    <section>
        <title>Ordering (FIFO covered by NAKACK)</title>
        <para></para>

        <section>
            <title>Total Order (SEQUENCER)</title>

            <para></para>
        </section>
    </section>

    <section>
        <title>Group Membership</title>

        <para>Group membership takes care of joining new members, handling leave
            requests by existing members, and handling SUSPECT messages for crashed
            members, as emitted by failure detection protocols. The algorithm for
            joining a new member is essentially:
            <screen>
                - loop
                - find initial members (discovery)
                - if no responses:
                - become singleton group and break out of the loop
                - else:
                - determine the coordinator (oldest member) from the responses
                - send JOIN request to coordinator
                - wait for JOIN response
                - if JOIN response received:
                - install view and break out of the loop
                - else
                - sleep for 5 seconds and continue the loop
            </screen>
        </para>


        <section>
            <title>pbcast.GMS</title>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>disable_initial_coord</entry>
<entry>If true this member can never become coordinator. Default is false</entry>
</row>
<row>
<entry>handle_concurrent_startup</entry>
<entry>Temporary switch. Default is true and should not be changed</entry>
</row>
<row>
<entry>join_timeout</entry>
<entry>Join timeout. Default is 5000 msec</entry>
</row>
<row>
<entry>leave_timeout</entry>
<entry>Leave timeout. Default is 5000 msec</entry>
</row>
<row>
<entry>max_bundling_time</entry>
<entry>Max view bundling timeout if view bundling is turned on. Default is 50 msec</entry>
</row>
<row>
<entry>merge_leader</entry>
<entry>If true this member is a designated merge leader. Default is false</entry>
</row>
<row>
<entry>merge_timeout</entry>
<entry>Timeout to complete merge. Default is 10000 msec</entry>
</row>
<row>
<entry>num_prev_mbrs</entry>
<entry>Max number of old members to keep in history. Default is 50</entry>
</row>
<row>
<entry>print_local_addr</entry>
<entry>Print local address of this member after connect. Default is true</entry>
</row>
<row>
<entry>reject_join_from_existing_member</entry>
<entry>Should repeated join requests from existing members be treated as errors. Default is true</entry>
</row>
<row>
<entry>resume_task_timeout</entry>
<entry>Timeout to resume ViewHandler. Default is 20000 msec</entry>
</row>
<row>
<entry>shun</entry>
<entry>Shunning toggle. Default is false</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>view_ack_collection_timeout</entry>
<entry>Time in ms to wait for all VIEW acks (0 == wait forever. Default is 2000 msec</entry>
</row>
<row>
<entry>view_bundling</entry>
<entry>Should views be bundled? Default is true</entry>
</row>
</tbody>
</tgroup>
</table>

			            

            <section>
                <title>Disabling the initial coordinator</title>

                <para>Consider the following situation: a new member wants to join a
                    group. The prodedure to do so is:
                </para>

                <itemizedlist>
                    <listitem>
                        <para>Multicast an (unreliable) discovery request (ping)</para>
                    </listitem>

                    <listitem>
                        <para>Wait for n responses or m milliseconds (whichever is
                            first)
                        </para>
                    </listitem>

                    <listitem>
                        <para>Every member responds with the address of the coordinator</para>
                    </listitem>

                    <listitem>
                        <para>If the initial responses are &gt; 0: determine the coordinator
                            and start the JOIN protocolg
                        </para>
                    </listitem>

                    <listitem>
                        <para>If the initial response are 0: become coordinator, assuming that
                            no one else is out there
                        </para>
                    </listitem>
                </itemizedlist>

                <para>However, the problem is that the initial mcast discovery request
                    might get lost, e.g. when multiple members start at the same time, the
                    outgoing network buffer might overflow, and the mcast packet might get
                    dropped. Nobody receives it and thus the sender will not receive any
                    responses, resulting in an initial membership of 0. This could result in
                    multiple coordinators, and multiple subgroups forming. How can we overcome
                    this problem ? There are 3 solutions:
                </para>

                <orderedlist>
                    <listitem>
                        <para>Increase the timeout, or number of responses received. This will
                            only help if the reason of the empty membership was a slow host. If
                            the mcast packet was dropped, this solution won't help
                        </para>
                    </listitem>

                    <listitem>
                        <para>Add the MERGE(2) protocol. This doesn't actually prevent
                            multiple initial cordinators, but rectifies the problem by merging
                            different subgroups back into one. Note that this involves state
                            merging which needs to be done by the application.
                        </para>
                    </listitem>

                    <listitem>
                        <para>(new) Prevent members from becoming coordinator on initial
                            startup. This solution is applicable when we know which member is
                            going to be the initial coordinator of a fresh group. We don't care
                            about afterwards, then coordinatorship can migrate to another member.
                            In this case, we configure the member that is always supposed to be
                            started first with disable_initial_coord=false (the default) and all
                            other members with disable_initial_coord=true.This works as described
                            below.
                        </para>
                    </listitem>
                </orderedlist>

                <para>When the initial membership is received, and is null, and the
                    property disable_initial_coord is true, then we just continue in the loop
                    and retry receving the initial membership (until it is non-null). If the
                    property is false, we are allowed to become coordinator, and will do so.
                    Note that - if a member is started as first member of a group - but its
                    property is set to true, then it will loop until another member whose
                    disable_initial_coord property is set to false, is started.
                </para>
            </section>

        </section>
    </section>


    <section>
        <title>Security</title>

        <para></para>
        <section>
            <title>ENCRYPT</title>
            
            <table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>alias</entry>
<entry>Alias used for recovering the key. Change the default</entry>
</row>
<row>
<entry>asymAlgorithm</entry>
<entry>Cipher engine transformation for asymmetric algorithm. Default is RSA</entry>
</row>
<row>
<entry>asymInit</entry>
<entry>Initial public/private key length. Default is 512</entry>
</row>
<row>
<entry>asymProvider</entry>
<entry>Cryptographic Service Provider. Default is Bouncy Castle Provider</entry>
</row>
<row>
<entry>encrypt_entire_message</entry>
<entry/>
</row>
<row>
<entry>keyPassword</entry>
<entry>Password for recovering the key. Change the default</entry>
</row>
<row>
<entry>keyStoreName</entry>
<entry>File on classpath that contains keystore repository</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>storePassword</entry>
<entry>Password used to check the integrity/unlock the keystore. Change the default</entry>
</row>
<row>
<entry>symAlgorithm</entry>
<entry>Cipher engine transformation for symmetric algorithm. Default is AES</entry>
</row>
<row>
<entry>symInit</entry>
<entry>Initial key length for matching symmetric algorithm. Default is 128</entry>
</row>
</tbody>
</tgroup>
</table>

        </section>

        <section>
            <title>AUTH</title>
        </section>
    </section>

    <section>
        <title>State Transfer</title>

        <section>
            <title>pbcast.STATE_TRANSFER</title>

            <para></para>
        </section>

        <section>
            <title>pbcast.STREAMING_STATE_TRANSFER</title>

            <section>
                <title>Overview</title>

                <para>In order to transfer application state to a joining member of a
                    group pbcast.STATE_TRANSFER has to load entire state into memory and
                    send it to a joining member. Major limitation of this approach is that
                    the state transfer that is very large (&gt;1Gb) would likely result in
                    OutOfMemoryException. In order to alleviate this problem a new state
                    transfer methodology, based on a streaming state transfer, was
                    introduced in JGroups 2.4
                </para>

                <para>Streaming state transfer supports both partial and full state
                    transfer.
                </para>

                <para>Streaming state transfer provides an InputStream to a state
                    reader and an OutputStream to a state writer. OutputStream and
                    InputStream abstractions enable state transfer in byte chunks thus
                    resulting in smaller memory requirements. For example, if application
                    state consists a huge DOM tree, whose aggregate size is 2GB (and which
                    has partly been passivated to disk), then the state provider (ie. the
                    coordinator) can simply iterate over the DOM tree (activating the
                    parts which have been passivated out to disk), and write to the
                    OutputStream as it traverses the tree. The state receiver will simply
                    read from the InputStream and reconstruct the tree on its side,
                    possibly again passivating parts to disk.
                </para>

                <para>Rather than having to provide a 2GB byte[] buffer, streaming
                    state transfer transfers the state in chunks of N bytes where N is
                    user configurable.
                </para>
            </section>

            <section>
                <title>API</title>

                <para>Streaming state transfer, just as regular byte based state
                    transfer, can be used in both pull and push mode. Similarly to the
                    current getState and setState methods of org.jgroups.MessageListener,
                    application interested in streaming state transfer in a push mode
                    would implement streaming getState method(s) by sending/writing state
                    through a provided OutputStream reference and setState method(s) by
                    receiving/reading state through a provided InputStream reference. In
                    order to use streaming state transfer in a push mode, existing
                    ExtendedMessageListener has been expanded to include additional four
                    methods:
                </para>

                <para>
                    <screen>
                        public interface ExtendedMessageListener
                        {

                        /*non-streaming callback methods ommitted for clarity*/


                        /**
                        * Allows an application to write a state through a provided OutputStream.
                        * An application is obligated to always close the given OutputStream reference.
                        *
                        * @param ostream the OutputStream
                        * @see OutputStream#close()
                        */
                        public void getState(OutputStream ostream);

                        /**
                        * Allows an application to write a partial state through a provided OutputStream.
                        * An application is obligated to always close the given OutputStream reference.
                        *
                        * @param state_id id of the partial state requested
                        * @param ostream the OutputStream
                        *
                        * @see OutputStream#close()
                        */
                        public void getState(String state_id, OutputStream ostream);


                        /**
                        * Allows an application to read a state through a provided InputStream.
                        * An application is obligated to always close the given InputStream reference.
                        *
                        * @param istream the InputStream
                        * @see InputStream#close()
                        */
                        public void setState(InputStream istream);

                        /**
                        * Allows an application to read a partial state through a provided InputStream.
                        * An application is obligated to always close the given InputStream reference.
                        *
                        * @param state_id id of the partial state requested
                        * @param istream the InputStream
                        *
                        * @see InputStream#close()
                        */
                        public void setState(String state_id, InputStream istream);

                        }
                    </screen>
                </para>

                <para>For a pull mode (when application uses channel.receive() to
                    fetch events) two new event classes will be introduced:
                </para>

                <para>
                    <itemizedlist>
                        <listitem>
                            <para>StreamingGetStateEvent</para>
                        </listitem>

                        <listitem>
                            <para>StreamingSetStateEvent</para>
                        </listitem>
                    </itemizedlist>
                    These two events/classes are very similar to
                    existing GetStateEvent and SetStateEvent but introduce a new field;
                    StreamingGetStateEvent has an OutputStream and StreamingSetStateEvent
                    has an InputStream.
                </para>

                <para>The following code snippet demonstrates how to pull events from
                    a channel, processing StreamingGetStateEvent and sending hypothetical
                    state through a provided OutputStream reference. Handling of
                    StreamingSetStateEvent is analogous to this example:
                </para>

                <screen>...
                    Object obj=channel.receive(0);
                    if(obj instanceof StreamingGetStateEvent) {
                    StreamingGetStateEvent evt=(StreamingGetStateEvent)obj;
                    OutputStream oos = null;
                    try {
                    oos = new ObjectOutputStream(evt.getArg());
                    oos.writeObject(state);
                    oos.flush();
                    } catch (Exception e) {}
                    finally{
                    try {
                    oos.close();
                    } catch (IOException e) {
                    System.err.println(e);
                    }
                    }
                    }
                    ...
                </screen>

                <para>API that initiates state transfer on a JChannel level has the
                    following methods:
                </para>

                <para>
                    <screen>public boolean getState(Address target,long timeout)throws
                        ChannelNotConnectedException,ChannelClosedException;
                        public boolean getState(Address target,String state_id,long timeout)throws
                        ChannelNotConnectedException,ChannelClosedException;
                    </screen>
                    Introduction of STREAMING_STATE_TRANSFER does
                    <emphasis>not</emphasis>
                    change the current API.
                </para>
            </section>

            <section>
                <title>Configuration</title>

                <para>State transfer type choice is static, implicit and mutually
                    exclusive. JChannel cannot use both STREAMING_STATE_TRANSFER and
                    STATE_TRANSFER in one JChannel configuration.
                </para>

                <para>STREAMING_STATE_TRANSFER allows the following confguration
                    parameters:
                </para>

				<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>bind_addr</entry>
<entry>The interface (NIC) used to accept state requests</entry>
</row>
<row>
<entry>bind_port</entry>
<entry>The port listening for state requests. Default value of 0 binds to any (ephemeral) port</entry>
</row>
<row>
<entry>max_pool</entry>
<entry>Maximum number of pool threads serving state requests. Default is 5</entry>
</row>
<row>
<entry>pool_thread_keep_alive</entry>
<entry>Keep alive for pool threads serving state requests. Default is 20000 msec</entry>
</row>
<row>
<entry>socket_buffer_size</entry>
<entry>Buffer size for state transfer sockets. Default is 8 KB</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>

            </section>

            <section>
                <title>Other considerations</title>

                <para>Threading model used for state writing in a member providing
                    state and state reading in a member receiving a state is tunable. For
                    state provider thread pool is used to spawn threads providing state.
                    Thus member providing state, in a push mode, will be able to
                    concurrently serve N state requests where N is max_threads
                    configuration parameter of the thread pool. If there are no further
                    state transfer requests pool threads will be automatically reaped
                    after configurable "pool_thread_keep_alive" timeout expires. For a
                    channel operating in the push mode state reader channel can read state
                    by piggybacking on jgroups protocol stack thread or optionally use a
                    separate thread. State reader should use a separate thread if state
                    reading is expensive (eg. large state, serialization) thus potentially
                    affecting liveness of jgroups protocol thread. Since most state
                    transfers are very short (&lt;2-3 sec) by default we do not use a
                    separate thread.
                </para>
            </section>
        </section>
    </section>


    <section>
        <title>Flow control</title>
        <para>
            Flow control takes care of adjusting the rate of a message sender to the rate of the slowest receiver over time.
            If a sender continuously sends messages at a rate that is faster than the receiver(s), the receivers will
            either queue up messages, or the messages will get discarded by the receiver(s), triggering costly
            retransmissions. In addition, there is spurious traffic on the cluster, causing even more retransmissions.
        </para>
        <para>
            Flow control throttles the sender so the receivers are not overrun with messages.
        </para>

        <section>
            <title>FC</title>
            <para>
                FC uses a credit based system, where each sender has <code>max_credits</code> credits and decrements
                them whenever a message is sent. The sender blocks when the credits fall below 0, and only resumes
                sending messages when it receives a replenishment message from the receivers.
            </para>
            <para>
                The receivers maintain a table of credits for all senders and decrement the given sender's credits
                as well, when a message is received.
            </para>
            <para>
                When a sender's credits drops below a threshold, the receiver will send a replenishment message to
                the sender. The threshold is defined by <code>min_bytes</code> or <code>min_threshold</code>.
            </para>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>ignore_synchronous_response</entry>
<entry/>
</row>
<row>
<entry>max_block_time</entry>
<entry>Max time (in milliseconds) to block. Default is 5000 msec</entry>
</row>
<row>
<entry>max_block_times</entry>
<entry>Max times to block for the listed messages sizes (Message.getLength())</entry>
</row>
<row>
<entry>max_credits</entry>
<entry>Max number of bytes to send per receiver until an ack must be received to proceed. Default is 500000 bytes</entry>
</row>
<row>
<entry>min_credits</entry>
<entry>Computed as max_credits x min_theshold unless explicitely set</entry>
</row>
<row>
<entry>min_threshold</entry>
<entry>If credits fall below this limit, we send more credits to the sender. Default is 0.25</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>


        </section>

        <section>
            <title>SFC</title>
            <para>
                A simplified version of FC. FC can actually still overrun receivers when the transport's latency is very
                small. SFC is a simple flow control protocol for group (= multipoint) messages.
            </para>
            <para>
                Every sender has max_credits bytes for sending multicast messages to the group.
            </para>
            <para>
                Every multicast message (we don't consider unicast messages) decrements max_credits by its size.
                When max_credits falls below 0, the sender asks all receivers for new credits and blocks
                until *all* credits have been received from all members.
            </para>

            <para>
                When the receiver receives a credit request, it checks whether it has received max_credits bytes from the requester since
                the last credit request. If yes, it sends new credits to the requester and resets the max_credits for the requester.
                Else, it takes a note of the credit request from P and - when max_credits bytes have finally been received from P - it
                sends the credits to P and resets max_credits for P.

            </para>
            <para>
                The maximum amount of memory for received messages is therefore &lt;number of senders&gt; * max_credits.

            </para>

            <para>
                The relationship with STABLE is as follows: when a member Q is slow, it will prevent STABLE from collecting messages above
                the ones seen by Q (everybody else has seen more messages). However, because Q will *not* send credits back to the senders
                until it has processed all messages worth max_credits bytes, the senders will block. This in turn allows STABLE to
                progress and eventually garbage collect most messages from all senders. Therefore, SFC and STABLE complement each other,
                with SFC blocking senders so that STABLE can catch up.

            </para>
			
			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>max_block_time</entry>
<entry>Max time (in milliseconds) to block. Default is 5000 msec</entry>
</row>
<row>
<entry>max_credits</entry>
<entry>Max number of bytes to send per receiver until an ack must be received to proceed. Default is 2000000 bytes</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>

        </section>
        
    </section>

    <section>
        <title>Message stability</title>
        <para>
            To serve potential retransmission requests, a member has to store received messages until it is known
            that every member in the cluster has received them. Message stability for a given message M means that M
            has been seen by everyone in the cluster.
        </para>
        <para>
            The stability protocol periodically (or when a certain number of bytes have been received) initiates a
            consensus protocol, which multicasts a stable message containing the highest message numbers for a
            given member. This is called a digest.
        </para>
        <para>
            When everyone has received everybody else's stable messages, a digest is computed which consists of the
            minimum sequence numbers of all received digests so far. This is the stability vector, and contain only
            message sequence numbers that have been seen by everyone.
        </para>
        <para>
            This stability vector is the broadcast to the group and everyone can remove messages from their
            retransmission tables whose sequence numbers are smaller than the ones received in the stability vector.
            These messages can then be garbage collected.
        </para>

        <section>
            <title>STABLE</title>

			<table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>desired_avg_gossip</entry>
<entry>Average time to send a STABLE message. Default is 20000 msec</entry>
</row>
<row>
<entry>max_bytes</entry>
<entry>Maximum number of bytes received in all messages before sending a STABLE message is triggered. Default is 0 (disabled)</entry>
</row>
<row>
<entry>stability_delay</entry>
<entry>Delay before stability message is sent. Default is 6000 msec</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
</tbody>
</tgroup>
</table>



        </section>

    </section>    

    <section>
        <title>Misc</title>

        <section>
            <title>COMPRESS</title>

            <para></para>
        </section>


        <section>
            <title>pbcast.FLUSH</title>

            <para>Flushing forces group members to send all their pending messages
                prior to a certain event. The process of flushing acquiesces the
                cluster so that state transfer or a join can be done. It is also
                called the stop-the-world model as nobody will be able to send
                messages while a flush is in process. Flush is used:
            </para>

            <para>
                <itemizedlist>
                    <listitem>
                        <para>State transfer</para>

                        <para>When a member requests state transfer it tells everyone to
                            stop sending messages and waits for everyone's ack. Then it asks
                            the application for its state and ships it back to the
                            requester. After the requester has received and set the state
                            successfully, the requester tells everyone to resume sending
                            messages.
                        </para>
                    </listitem>

                    <listitem>
                        <para>View changes (e.g.a join). Before installing a new view
                            V2, flushing would ensure that all messages *sent* in the
                            current view V1 are indeed *delivered* in V1, rather than in V2
                            (in all non-faulty members). This is essentially Virtual
                            Synchrony.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>

            <para>FLUSH is designed as another protocol positioned just below the
                channel, e.g. above STATE_TRANSFER and FC. STATE_TRANSFER and GMS
                protocol request flush by sending a SUSPEND event up the stack, where
                it is handled by the FLUSH protcol. The SUSPEND_OK ack sent back by
                the FLUSH protocol let's the caller know that the flush has completed.
                When done (e.g. view was installed or state transferred), the protocol
                sends up a RESUME event, which will allow everyone in the cluster to
                resume sending.
            </para>

            <para>Channel can be notified that FLUSH phase has been started by
                turning channel block option on. By default it is turned off. If
                channel blocking is turned on FLUSH notifies application layer that
                channel has been blocked by sending EVENT.BLOCK event. Channel
                responds by sending EVENT.BLOCK_OK event down to FLUSH protocol. We
                recommend turning on channel block notification only if channel is
                used in push mode. In push mode application that uses channel can
                perform block logic by implementing MembershipListener.block()
                callback method.
            </para>
            
            <table>
<title>Properties</title>
<tgroup cols="2">
<colspec align="left"/>
<thead>
<row>
<entry align="center">Name</entry>
<entry align="center">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>enable_reconciliation</entry>
<entry>Reconcilliation phase toggle. Default is true</entry>
</row>
<row>
<entry>flush_retry_count</entry>
<entry>Max number of attempts to quiet the cluster during first flush phase. Default is 4</entry>
</row>
<row>
<entry>retry_timeout</entry>
<entry>Retry timeout after an unsuccessful attempt to quiet the cluster (first flush phase). Default is 3000 msec</entry>
</row>
<row>
<entry>start_flush_timeout</entry>
<entry>Timeout (per atttempt) to quiet the cluster during the first flush phase. Default is 2500 msec</entry>
</row>
<row>
<entry>stats</entry>
<entry>Determines whether to collect statistics (and expose them via JMX). Default is true</entry>
</row>
<row>
<entry>timeout</entry>
<entry>Max time to keep channel blocked in flush. Default is 8000 msec</entry>
</row>
</tbody>
</tgroup>
</table>
			

        </section>
    </section>

   
</chapter>