
RELAY - replication between data centers
========================================

Author: Bela Ban
Version: $Id: RELAY.txt,v 1.3 2010/11/08 14:05:15 belaban Exp $

This is an enhanced version of DataCenterReplication.txt with the ability to send unicast messages and to provide views
to the application, which list members of all local clusters.

We have data centers with a local cluster each in New York (NYC) and San Francisco (SFO). The idea is to relay
traffic from NYC to SFO, and vice versa.

In case of a site failure of NYC, the state is available in SFO, and all clients can be switched over to SFO and
continue working with (almost) up-to-date data. The failing over of clients to SFO is outside the scope of this
proposal, and could be done for example by changing DNS entries, load balancers etc.

The data centers in NYC and SFO are *completely autonomous local clusters*. There are no stability, flow control or
retransmission messages exchanged between NYC and SFO. This is critical because we don't want the SFO cluster to block
for example on waiting for credits from a node in the NYC cluster !

For the example, we assume that each site uses a UDP based stack, and relaying between the sites uses a
TCP based stack, see figure RELAY.png.

There is a local cluster, based on UDP, at each site and one global cluster, based on TCP, which connects the
two sites. Each coordinator of the local cluster is also a member of the global cluster, e.g. member A in NYC
(assuming it is the coordinator) is also member X of the TCP cluster. This is called a *relay* member. A relay
member is always member of the local and global cluster.

A relay member has a UDP stack which additionally contains a protocol RELAY at the top (shown in the bottom part
of the figure). RELAY has a JChannel which connects to the TCP group, but *only* when it is (or becomes) coordinator
of the local cluster. The configuration of the TCP channel is done via a property in RELAY.

A multicast message received by RELAY traveling up the stack is wrapped and sent via the TCP channel to the
other site. When received there, the corresponding RELAY protocol unwraps the original message and changes the sender
of the message to a ProxyUUID, which wraps the original sender and the local sender.

A ProxyUUID extends UUID and behaves like a normal UUID, but it also contains the original sender.

A unicast message received by RELAY traveling down the stack is forwarded to the current relay if the destination is
a ProxyUUID. The relay will then wrap the message and forward it to the other site via TCP.

When forwarding a message to the local cluster, RELAY adds a header. When it receives the multicast message it
forwarded itself, and a header is present, it does *not* relay it back to the other site but simply drops it.
Otherwise, we would have a cycle.

When a coordinator crashes or leaves, the next-in-line becomes coordinator and activates the RELAY protocol,
connecting to the TCP channel and starting to relay messages.

However, if we receive messages from the local cluster while the coordinator has crashed and the new one hasn't taken
over yet, we'd lose messages. Therefore, we need additional functionality in RELAY which buffers the last N messages
(or M bytes, or for T seconds) and numbers all messages sent. This is done by the second-in-line.

When there is a coordinator failover, the new coordinator communicates briefly with the other site to determine
which was the highest message relayed by it. It then forwards buffered messages with lower numbers and removes the
remaining messages in the buffer. During this replay, message relaying is suspended.

Therefore, a relay has to handle 3 types of messages from the global (TCP) cluster:
 (1) Regular multicast messages
 (2) A message asking for the highest sequence number received from another relay, and the response to this
 (3) A message stating that the other side will go down gracefully (no need to replay buffered messages)


Example walkthrough
-------------------

Multicasting a message:

- C (in the NYC cluster, with coordinator A) multicasts a message
- A, B and C receive the multicast
- A is the relay. The byte buffer is extracted and a new message M is created. M's source is C, the dest is null
  (= send to all). Note that the original headers are *not* sent with M. If this is needed, we need to revisit.
- A then wraps M into a message sent from X to Y
- X receives M, drops it (because it is the sender, determined by the header).
- Y receives M, and unwraps it.
- Y replaces the sender (C) with a ProxyUUID(D,C) (D is the sender and C the origial sender), adds a RelayHeader and
  sends it down its local cluster
- D, E and F receive M and deliver it
- D does not relay M because M has a header

Sending a unicast reply:

- When F receives the multicast message M, it sends a unicast reply message R
- R.dest=ProxyUUID(D,C) and R.src=F
- RELAY.down() sees that R.dest is a ProxyUUID and therefore forwards R to the current relay (which is D)
- D sets the destination of R to C, wraps the message and sends it to X (via the TCP cluster)
- Y receive R and replaces R.src with a ProxyUUID(C,F)
- Y puts R on the local channel where it is sent to C


