
FLUSH protocol for default stack
================================

Author: Bela Ban
Version: $Id: FLUSH.txt,v 1.6 2006/05/22 07:04:50 belaban Exp $

Overview
--------
Flushing means that all members of a group flush their pending messages. The process of flushing acquiesces the cluster
so that state transfer or a join can be done. It is also called the stop-the-world model as nobody will be able to
send messages while a flush is in process.

When is it needed ?
-------------------
(1) On state transfer. When a member requests state transfer, the coordinator tells everyone to stop sending messages
and waits for everyone's ack. Then it asks the application for its state and ships it back to the requester. After
the requester has received and set the state successfully, the coordinator tells everyone to resume sending messages.

(2) On view changes (e.g.a join). Before installing a new view V2, flushing would ensure that all messages *sent* in the
current view V1 are indeed *delivered* in V1, rather than in V2 (in all non-faulty members). This is essentially
Virtual Synchrony.

Design
------
As another protocol FLUSH which handles a FLUSH event. FLUSH sits just below the channel, e.g. above STATE_TRANSFER
and FC. STATE_TRANSFER and GMS can be configured with a boolean use_flush attribute which determines whether flushing
is used on state transfer and/or view changes. If so, the protocol just sends a SUSPEND event up the stack, where it
is handled by the FLUSH protcol. The SUSPEND_OK ack sent back by the FLUSH protocol let's the caller know that the
flush has completed.
When done (e.g. view was installed or state transferred), the protocol sends up a RESUME event, which will allow
everyone in the cluster to resume sending.

FLUSH protocol:
- On SUSPEND event: multicast START_FLUSH to everyone (including self)

- On reception of START_FLUSH:
  - invoke the blockOK() callback
  - set suspended flag to true, all subsequent down() methods will block on mutex
  - *multicast* a FLUSH_OK message

- On reception of FLUSH_OK at non-coordinator: discard

- On reception of FLUSH_OK at coordinator:
  - Record FLUSH_OK in vector (1 per member)
  - Once FLUSH_OK messages have been received from all members --> send down SUSPEND_OK event
    (in case of crash notification: mark that member's entry as received, so we don't hang forever)

- On RESUME event: multicast STOP_FLUSH message

- On reception of STOP_FLUSH message: unblock down()

- On view change:
  - Mark crashed member as 'received' (see above)

- On suspect(P)
  - If P is the coordinator and we're next in line
    - Run the FLUSH protocol from scratch

Notes
-----
*Multicasting* (as compared to unicasting) the FLUSH_OK message is required so we can be sure that the FLUSH_OK
message sent by P is the last message received from P before P stopped sending messages. Since we're waiting on
everyone's FLUSH_OK, we can be assured that everyone's previous messages were received (thanks to reliable mcast).


FLUSH on view change
--------------------
Whenever there is a view change, GMS needs to use FLUSH to acquiesce the group, before sending the view change message
and returning the new view to the joiner. Here's pseudo code of the coordinator A in group {A,B,C}:
- On reception of JOIN(D):
  - FLUSH(A,B,C) - wait until flush returns, we flush A, B and C, but onviously not D
  - Compute new view V2={A,B,C,D}
  - Multicast V2 to {A,B,C}, wait for all acks
  - Send JOIN_RSP with V2 to D, wait for ack from D
  - RESUME sending messages

This algorithm also works for a number of JOIN and LEAVE requests (view bundling):
- On handleJoinAndLeaveRequests(M, S, L, J), where M is the current membership, S the set of suspected members,
  L the set of leaving members and J the set of joined members:
  - FLUSH(M)
  - Compute new view V2=M - S - L + J
  - Multicast V2 to M-S, wait for all acks
  - Send LEAVE_RSP to L, wait for all acks
  - Send JOIN_RSP to J, wait for all acks
  - Resume sending messages
  

FLUSH with join & state transfer
--------------------------------
- A new method Channel.connect(String group, boolean transfer_state, String state_id) will be added
- The JOIN_REQ contains the boolean
- The algorithm in GMS is the same as the two described above, except that before multicasting the new view and sending
  the JOIN_RSPs and LEAVE_RSPs, we ask the application for its state (GET_APPLSTATE) and when received (GET_APPLSTATE_OK),
  we send it back to the joining member(s), and the RESUME sending messages
