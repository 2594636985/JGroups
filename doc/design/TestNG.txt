

Migration from JUnit to TestNG
==============================

Author Bela Ban
Version: $Id: TestNG.txt,v 1.9 2008/03/04 16:01:05 belaban Exp $

Goals
-----

1. Reduce unnecessary channel creations, cluster joins and cluster leaves
   - Example: if we have 10 methods in a test class, we create and connect to a channel
     in setup() and disconnect and tear down the channel in tearDown() for *each* test method
   - Unless channel creation/tear down is tested (like in CloseTest), we can create a connect to the
     channel before the test, and disconnect and tear down the channel after all 10 methods have been executed
   - This will save us the cost of 9 channel creations/connects/disconnects

2. Run all the tests in separate threads
   - A thread pool (say 20 threads, depending on how many core we have) is configured
   - All tests are processed by different threads in that pool
   - The first 20 tests to be run are processed: each test is run by a separate thread
   - When a thread is done, it grabs the next test, until no more tests are available
   - All methods inside a given test are still executed *sequentially*, this is necessary as different methods within
     a test modify shared state, e.g. a view or the number of messages received, and are therefore dependent on
     running sequentially
   - We need to make sure we dynamically change mcast addresses / ports so that we don't have overlapping traffic 
   - Later, we might be able to take advantage of annotations which mark an entire test, such that it can be executed
     concurrently
   - This is similar to TestNG's parallel="methods" | "tests", but TestNG doesn't currently have a mode which allows for
     concurrent execution of different tests (with sequential execution of methods inside those tests)
   - We probably have to extend TestNG to do this:
     - parallel="tests", but provide a list of tests (one for each test class) to TestNG *programmatically*
   - The dependOn{Methods,Groups} option allows us to define an ordering between methods of a test. However, this
     requires detailed dependency analysis between the methods of a test. While this probably makes parallel
     processing even faster (as we don't need sequential processing for methods inside a test), we should do it
     in a second stage. This would allow us to use parallel="tests" or even "methods"

x. Different stack configs (udp, tcp, mux-udp, mux-tcp etc)
   - As data providers ?
   - @Parameter annotation, e.g.

     @Parameter(name="channel.conf") // defined in the ChannelTestsBase (or whichever) super class
     public void setupStack(String config) {
         channel=createChannel(config);
     }

   - The @Parameter annotation is probably better than data providers, as we can run the stack dependent test suites
     as separate tests, with different parameters, e.g.:

     <suite name="JGroups test suite">
        <test name="UDP tests">
            <parameter name="channel.conf"  value="udp.xml"/>
        </test>
        <test name="TCP tests">
            <parameter name="channel.conf"  value="tcp.xml"/>
        </test>
        <test name="mux-udp tests">
            <parameter name="channel.conf"  value="mux-udp"/>
        </test>

        <test name="mux-tcp tests">
            <parameter name="channel.conf"  value="mux-tcp"/>
        </test>
        ...
     </suite>

x. Distributed execution across a cluster
   - Same as #2, but different tests are run on different hosts
   - The thread pool consists of different threads pools, hosted by different boxes
   - http://beust.com/weblog/archives/000362.html ?


Todos:
------
- Convert all tests to TestNG (use TestNG's automatic converter or use awk.sed ?)
- Remove junit.jar, add testng.jar
- Write correct TestNG XML file
- Integrate with build.xml


Questions, issues
-----------------

- Why are methods in *superclasses* annotated with @BeforeTest, @BeforeClass etc *not* invoked ?
- Identify useful group names and use those consistently
  - udp, mux-udp, tcp, mux-tcp ?
  - functional ?
  - stack-dependent ?
  
