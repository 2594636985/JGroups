

Multiplexing functionality
===========================

Author: Bela Ban
Version: $Id: Multiplexer.txt,v 1.5 2006/02/17 12:56:32 belaban Exp $
JIRA: http://jira.jboss.com/jira/browse/JGRP-119, http://jira.jboss.com/jira/browse/JGRP-112

Overview
--------
In JBoss we have multiple JGroups channels, one for each application (e.g. JBossCache, ClusterPartition etc). The goal of
the Multiplexer is to combine all stacks with the *same* configuration into one, and have multiple apps on top
of that same channel.
To do this we have to introduce multiplexing and demultiplexing functionality, ie. each app will have to have
a unique application ID (a string), and when sending a message, the message has to be tagged with that ID. When
receiving a message, it will be dispatched to the right app based on the ID attached to the message.
We require special handling for VIEW and SUSPECT messages: those need to be dispatched to *all* apps.
State transfer also needs to be handled specially, here we probably have to use thread locals, or change the API (TBS).

When deployed into JBoss, the Multiplexer will be exposed as an MBean, and all apps that depend on it will be deployed
with dependency injection on the Multiplexer. Of course, the old configuration will still be supported.

The config of the Multiplexer is done via a config file, which lists a number of stacks, each keyed by a name, e.g.
"udp", "tcp", "tcp-nio" etc. See ./conf/stacks.xml for an example. An app is configured with the name of a stack, e.g.
"udp", and a reference to the Multiplexer MBean. It will get a proxy channel through which all of its communication
will take place. The proxy channel (MuxChannel) will mux/demux messages to the real JGroups channel.

The advantage of the Multiplexer is that we can reduce N channels into M where M < N. This means fewer threads, therefore
fewer context switches, less memory consumption and easier configuration and better support.


Design
------
The Multiplexer is implemented by extending the JChannelFactory class. When an app wants to fetch a channel, it calls
Channel createChannel(String stack_name, Receiver receiver, String id) on the factory. The arguments define the stack
name (e.g. "udp"), the receiver that will be called when messages and view changes arrive, and the application ID.
The factory then returns a MuxChannel (a subclass of Channel), and all calls made against the MuxChannel are
redirected to the factory (some go directly to the JGroups Channel). The subsequent sections describe the various
use cases, e.g. life cycle for channel creation, message sending and reception, channel close/disconnect, view
reception and state transfer.



Configuration
-------------
Configuration is via XML, example is ./conf/stacks.xml. The file defines a number of stacks, each is given a unique
name. This name is used in JChannelFactory.createChannel() as stack name.

Structures
----------
- mux-table: Map<JChannel, MuxReceiver>. A hashmap of channels and their associated MuxReceivers. A MuxReceiver implements
  org.jgroups.UpHandler and keeps track of all Receivers attached to a given JChannel.
  It also stores the name under which the channel was created. Whenever up() is called, it removes the header (containing
  the application ID and dispatches the call to the right Receiver (or receiver-queue is enabled).

- app-table: Map<String, AppReceiver>. A hashmap of application IDs and AppReceivers. AppReceivers implement
  org.jgroups.Receiver and keep a reference to the Receiver provided by the application when calling createChannel().
  The main task of an AppReceiver is to buffer callbacks if enabled. Otherwise, a callback on AppReceiver is simply
  calling the corresponding callback on receiver.

Possibly, MuxReceivers and AppReceivers could - instead of implementing Receiver - register as an UpHandler with
the JChannel, setUpHandler().

JChannelFactory initialization
------------------------------
JChannelFactory has a reference to the configuration which is set either on creation (e.g. via JMX attribute) when
used as an MBean, or via one of the config() methods.
The JChannelFactory MBean has to support the JMX life cycle methods (create(), start(), stop(), destroy()).

MuxChannel creation
-------------------
When JChannelFactory.createChannel() is called, the following happens:
-

MuxChannel connect
------------------

Sending a message on MuxChannel
-------------------------------

Receiving a message on MuxReceiver
----------------------------------

View change
-----------

State transfer
--------------

MuxChannel disconnect/close
---------------------------






