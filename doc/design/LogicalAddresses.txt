

Logical addresses
=================

Author:  Bela Ban
Version: $Id: LogicalAddresses.txt,v 1.7 2009/02/10 13:06:50 belaban Exp $
JIRA:    https://jira.jboss.org/jira/browse/JGRP-129

The address chosen by each node is essentially the IP address and port of the receiver socket. However, for the
following reasons, this is not good enough:

- Reincarnation: if we use fixed ports (bind_port is set), then a restarted (or shunned) node will have the same
  address. If other nodes in the cluster don't clear their states before the reincarnated node comes up again, we'll
  have issues (see JGRP-130 for details)

- NIC failover: a NIC goes down, we want to continue sending/receiving on a different NIC

- The sender sends on all available NICs (send_on_all_interfaces="true"). This means that -if we take the receiver's
datagram packet's address to be the identity of the sender - we get N different identities; 1 for each interface
the message is sent on

- Network Address Translation: the sender's address might get changed by the NAT

DESIGN:

- A logical address consists of a unique identifier (UUID) and a logical name. The name is passed to JGroups when a
 channel is created (new JChannel(String logical_name, String props)). If logical_name is null, JGroups picks a
 logical name (which is not guaranteed to be unique though). The logical name stays with the channel until the latter
 is destroyed

- A UUID is represented by org.jgroups.util.UUID, which is a subclass of Address and consists of the least and
  most significant bits variables copied from java.util.UUID. All other instance variables are omitted.
  - The isMulticastAddress() method uses 1 bit out of the 128 bits of UUID
    (Maybe we can remove this method and always represent multicast addresses as nulls, so UUIDs would only be used
     to represent non multicast addresses)

- All UUIDs have a reference to a static table which contains the mappings between logical names and UUIDs
  (classloader issues ?)

- The logical name is used in UUID.toString(), and the least and most significant bits are used for equals() and
  hashCode()

- A UUID is created on channel connect, deleted on channel disconnect and re-created on channel connect.
  Since it is re-created on every connect(), it will prevent reincarnation issues

Transport (TP)
--------------

TP maintains a cache of mappings between UUIDs and physical addresses. Whenever a message is sent, the physical address
of the receiver is looked up from the cache.

A UUID can have more than 1 physical address. We envisage providing a pluggable strategy which picks a physical
address given a UUID. For example, a plugin could load balance between physical addresses.

To exchange cache information, we'll use a simple (TP-internal) protocol similar to ARP. Whenever the cache is changed,
we set a 'dirty' flag. The next down message(s) will then attached the cache contents to the message in an additional
I-HAVE header. Receiving nodes will update their local caches upon reception.

When a physical address for a given UUID is not present, a sender discards (or queues, TBD) the message and broadcasts
a WHO-HAS message. Receivers then broadcast (or unicast) the UUID-physical address mapping.

The discovery phase needs to return logical *and* physical addresses: on reception of a discovery request, we return
our logical address (UUID) and the physical address(es) associated with it, plus the logical name. On reception
of a discovery response, the transport places the physical addresses returned into its cache (if not yet present).
See the scenarios below for details as to why this is needed.


UDP startup
-----------
- The joiner multicasts a discovery request with its UUID, logical name and physical address(es)
- The receivers' transports add this information into their caches
- Each receiver unicasts a discovery response, containing the coordinator's address, plus its own UUID, logical
  name and physical address(es)
- On reception of a discovery response, the transport adds this information to its cache if not yet there


TCPPING:TCP startup
-------------------
- The problem is that TCPPING has as initial_hosts the *physical* (not logical) addresses listed !
- The joiner sends a discovery request to all nodes listed in initial_hosts
- The destination address is now a physical address (IpAddress), not a UUID
- The transport usually converts UUIDs to physical addresses using a cache lookup
- However, if a check reveals that the dest is a physical address, we simply *use* that physical address and
  don't do the translation UUID --> physical address
- On the receiver side, the destination is not used for discovery
- The response is sent back to the sender (Message.getSrc()), this is a UUID and will be translated back
  into a physical address


TCPGOSSIP:TCP startup
---------------------
- The joiner asks the GossipRouter for a list of nodes for a given cluster name
- The information returned contains a list of nodes, for each node:
  - The logical address (UUID)
  - The logical name
  - The physical address(es) associated with the UUID
- The joiner's transport adds this information to its cache
- Then each node of the initial membership is sent a discovery request
- The rest is the same as for UDP


TCPGOSSIP:TUNNEL startup
------------------------
- Same as for TCPGOSSIP:TCP, but here we don't really need the physical addresses, because we send every request
  to the GossipRouter anyway (via our TCP connection to it)
- The physical address will simply be ignored



TODOs
-----
- Multicast messages should always be null, so Address.isMulticastAddress() should not be needed anymore
- GossipRouter: we need to register logical *and* physical addresses, plus the logical name
- Find all uses of IpAddress and change them to SocketAddress (if possible), or try to use Address rather than
  IpAddress
- [TBD] Change IpAddress into PhysicalAddress (?)
- UUID: generate a nice name from UUID if the logical name is not defined. Alternative: don't use the UUID to generate
  the logical name, but maybe the host name and a random short



